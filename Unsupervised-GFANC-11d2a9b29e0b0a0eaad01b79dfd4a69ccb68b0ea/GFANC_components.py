import torch
import torch.nn as nn
import torch.nn.functional as F

class CoProcessorCNN(nn.Module):
    def __init__(self, M=15):
        super(CoProcessorCNN, self).__init__()
        # Lightweight 1D CNN config
        # Input: [Batch, 1, 16000] (1 second at 16kHz)
        
        self.features = nn.Sequential(
            # Layer 1
            nn.Conv1d(1, 16, kernel_size=64, stride=2, padding=32),
            nn.BatchNorm1d(16),
            nn.ReLU(),
            nn.MaxPool1d(4),
            
            # Layer 2
            nn.Conv1d(16, 32, kernel_size=32, stride=2, padding=16),
            nn.BatchNorm1d(32),
            nn.ReLU(),
            nn.MaxPool1d(4),
            
            # Layer 3
            nn.Conv1d(32, 64, kernel_size=16, stride=2, padding=8),
            nn.BatchNorm1d(64),
            nn.ReLU(),
            nn.MaxPool1d(4),
        )
        
        # Calculate flatten size: 
        # 16000 -> /2/4 -> 2000 -> /2/4 -> 250 -> /2/4 -> ~31
        # Let's verify shape in forward or just use AdaptiveAvgPool for safety
        
        self.global_pool = nn.AdaptiveAvgPool1d(1)
        
        self.fc = nn.Sequential(
            nn.Linear(64, 64),
            nn.ReLU(),
            nn.Linear(64, M), # M soft weights
            nn.Sigmoid()      # Constraint: 0 to 1
        )

    def forward(self, x):
        # x shape: [Batch, 1, samples]
        x = self.features(x)
        x = self.global_pool(x)
        x = x.squeeze(2) # [Batch, 64]
        weights = self.fc(x) # [Batch, M]
        return weights

class GFANC_Controller(nn.Module):
    def __init__(self, sub_filters, secondary_path, filter_len=1024):
        super(GFANC_Controller, self).__init__()
        # sub_filters: Tensor [M, filter_len]
        # secondary_path: Tensor [1, 1, s_len]
        
        self.register_buffer('sub_filters', sub_filters) # Fixed, no grad
        self.register_buffer('secondary_path', secondary_path) # Fixed, no grad
        self.filter_len = filter_len
        
    def forward(self, ref_noise, disturbance, weights, prev_x=None, prev_y=None):
        """
        ref_noise: [Batch, 1, chunk_len] (Input Noise x)
        disturbance: [Batch, 1, chunk_len] (Primary Noise d)
        weights: [Batch, M] (Generated by CoProcessor)
        prev_x: [Batch, 1, filter_len - 1] (State for W convolution)
        prev_y: [Batch, 1, sec_path_len - 1] (State for S convolution)
        """
        batch_size = ref_noise.shape[0]
        chunk_len = ref_noise.shape[2]
        
        # 1. Construct Control Filter W
        w_expanded = weights.unsqueeze(2) # [B, M, 1]
        filters_expanded = self.sub_filters.unsqueeze(0).expand(batch_size, -1, -1) # [B, M, L]
        # Weighted sum of filters
        W = torch.sum(w_expanded * filters_expanded, dim=1, keepdim=True) # [B, 1, L]
        
        # 2. Generate Anti-Noise y = x * W (Stateful Convolution)
        # Pad with previous state (overlap-save method)
        if prev_x is None:
            # Initial state: zeros
            prev_x = torch.zeros(batch_size, 1, self.filter_len - 1, device=ref_noise.device)
            
        x_padded = torch.cat((prev_x, ref_noise), dim=2) # [B, 1, L-1 + Chunk]
        
        # Reshape for grouped conv
        x_reshaped = x_padded.view(1, batch_size, x_padded.shape[2]) # [1, B, T_pad]
        
        # Valid convolution: Output length = Input - Filter + 1
        # (L-1 + Chunk) - L + 1 = Chunk. Perfect.
        y = F.conv1d(x_reshaped, W, padding=0, groups=batch_size) 
        y = y.view(batch_size, 1, -1) # [B, 1, Chunk]
        
        # Update State x: Keep last L-1 samples
        next_prev_x = x_padded[:, :, - (self.filter_len - 1):]
        
        # 3. Filter with Secondary Path y' = y * S (Stateful Convolution)
        s_len = self.secondary_path.shape[2]
        if prev_y is None:
            prev_y = torch.zeros(batch_size, 1, s_len - 1, device=ref_noise.device)
            
        y_padded = torch.cat((prev_y, y), dim=2)
        y_prime = F.conv1d(y_padded, self.secondary_path, padding=0) # [B, 1, Chunk]
        
        # Update State y
        next_prev_y = y_padded[:, :, - (s_len - 1):]
        
        # 4. Calculate Error e = d - y'
        error = disturbance - y_prime
        
        return error, y_prime, W, next_prev_x, next_prev_y
